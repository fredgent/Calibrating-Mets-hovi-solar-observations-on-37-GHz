
  %FAG: trying to disembiguate use of 'sample'
  %Each sample observation yields an intensity map with coordinates right 
  %Each observation scan yields an intensity map with coordinates right 
  %ascension, $\RA$, and declination, $\Dec$.
  %Each scan, denoted $S$ and spanning a couple of minutes, comprises a set of beam-size specimens. For $s_i \in S$:
  %FAG: trying to disembiguate use of 'sample'
  %SKK: maybe it could be clearer:
  %FAG added
  %from which the initial radius of the disk, $r^(0)$, is estimated (Sect.~\ref{sect:initial_radius}). 
  %The superscript, 
  %(0), is used to indicate the initial values, which are then refined by an iterative process described in 
  %Sect.~\ref{sect:iterative_calibration}, \ref{sect:outliers_disk} and \ref{sect:outliers_limb}. Following sufficient 
  %iterations we obtain calibrated maps $S^{(k)}$, from which we proceed to analyze and map the data onto heliographic 
  %coordinates and time series.
  %FAG: ended
  %\skk{There are no superscripts or subscripts for $S$. I have included the progressive calibration steps as additional 
  %values included in the bundles $s_i\in S$.}
  
%------------------------------------------------------------------------------
  \subsection{Initial normalisation}\label{sect:s_curve}
%------------------------------------------------------------------------------

  \fag{Perhaps most of the following details could be moved to an appendix and 
  here we just summarise the key points of the stage?}
  The domain of the first optimization round ($k=1$) contains the whole map:
  \eqnl{scurve-firstdomain}{
  \s{j}{min}^{(1)} := 1 \; \text{and} \; \s{j}{max}^{(1)} := N_S \text{,}
  }
  while the subsequent domain will be defined based on result of the previous optimization round. After obtaining 
  $P_k(u)$, we calculate the root $\s{u}{root}^{(k)}$, where the curvature of $P_k(u)$ changes from negative to 
  positive:
  \eqnl{scurve-root}{
  P_k^{\prime\prime}(\s{u}{root}^{(k)}) = 0 \implies \s{u}{root}^{(k)} = -\frac{a_2^{(k)}}{3 a_3^{(k)}} \text{.}
  }
  The root defines the pivot index for separating the disk from the background:
  \eqnl{scurve-pivot}{
  \s{j}{pivot}^{(k)} := P_k(\s{u}{root}^{(k)}) \text{.}
  }
  The representatives can now be assigned based on the pivot index as:
  \eqnl{scurve-background}{
  \s{u}{background}^{(k)} := w^{-1} \left( \floor{\frac{\s{j}{pivot}^{(k)} + 1}{2} + 0.5} \right) \text{and}
  }
  \eqnl{scurve-disk}{
  \s{u}{disk}^{(k)} := w^{-1} \left( \floor{\frac{\s{j}{pivot}^{(k)} + 2 N_S}{3} + 0.5} \right) \text{.}
  }
  The domain of the subsequent round is specified using the representatives:
  \eqnl{scurve-nextdomain-min}{
  \s{j}{min}^{(k+1)} := w \left( \floor{ 0.9 * \s{u}{background}^{(k)} + 0.1 * \s{u}{disk}^{(k)} + 0.5 } \right) \text{and}
  }
  \eqnl{scurve-nextdomain-max}{
  \s{j}{max}^{(k+1)} := w \left( \floor{ 0.1 * \s{u}{background}^{(k)} + 0.9 * \s{u}{disk}^{(k)} + 0.5 } \right) \text{.}
  }
  We then perform the next step $k := k+1$ and start by fitting a new polynomial in Equation~\ref{scurve-approx}. The 
  idea is that for the second round, we only use the limb samples and could expect a better fitting of $P_2$ compared to 
  $P_1$, while the $P_1$ already works well enough to find the plateau from full $w(u)$. The fitting in the second round is illustrated in Fig.~\ref{S-curve_example}{\bf(b)}.

  It is sufficient to stop the iteration at the second round and set:
  \eqnl{scurve-converged}{
  \s{u}{background} := \s{u}{background}^{(2)} \; \text{and} \; \s{u}{disk} := \s{u}{disk}^{(2)} \text{.}
  }
  It is also possible to use an odd order $n > 3$ for Equation~\ref{scurve-approx} and obtain slightly better precision 
  for the pivot $\s{i}{pivot}^{(k)}$. This leads to a failure if the resulting second differential $P_k^{\prime\prime}(u)$ 
  has zero or even number of real roots. Otherwise we can select the middle real root and proceed.

  %FAG: rephrased
  %Sections~\ref{sect:s_curve} and~\ref{sect:initial_centering} describe the initial calibration step performed for the solar maps. This is based on an oral description 
  %given by Juha Aatrokoski at MRO, and a similar calibration method is commonly used at MRO.
  The initial normalisation and centering methods described here and in Sect.~\ref{sect:initial_centering} derive from 
  an oral outline given by Juha Aatrokoski at MRO of the calibration method commonly used at MRO, including 
  \citet{metsahovi40}.
  %\skk{Thanks Fred!}

  %FAG: removed para break and rephrase
  %In order to extract representatives $\s{u}{background}$ and $\s{u}{disk}$, we will first obtain a list of samples in 
  %map $S$, sorted by their raw intensity values $u_i$. Let $I_S$ be the set of indices for samples in $S$:

  In this step we initialise $\s{u}{background}$ and $\s{u}{disk}$. The samples in map $S$ are sorted by their raw 
  intensity values $u_i$. 
%\fag{I think this may be unnecessarily detailed (verbose). It can be summarised in words, 
%  alternative below...}i
 Let $I_S$ be the set of indices for samples in $S$:

%  \skk{Whether it is \emph{initialize} or \emph{initialise}, I think this time it is a thing which A\&A should decide.}

  \eqnl{S-curve_indices}{
  I_S = \left\{ 1, 2, ..., N_S \right\} \text{.}
  }
  We construct a monotonous integer function $w^{-1}$, such that
  $w^{-1}(j) = u_j$.
  The integer $j$ denotes the index of the re-ordered sample set $S = \left\{ s_j \right\}$ such
  that $j \le j^{\prime} \Leftrightarrow u_{j} \le u_{j^{\prime}}.$
  In Fig.~\ref{S-curve_example}{\bf(a)} , the inverse $w(u)$ is plotted against
  $u$ for a typical scan. For mathematical rigor, we need to handle the case of several samples having identical intensity:
  \eqnl{scurve-inverse-rigor}{
  w:\;\real \mapsto I_S, \quad w(u) = \max{0, j \in I_S:\; w^{-1}(j) \le u} \text{.}
  }

%  \skk{I included Fred's alternative wording but retained some of the formalism. I still need the index set $I_N$ later on.}

  %We are now free to choose the statistical functions $f$, $g$, $h$ which now describe the calibration algorithm. It is 
  %an open question whether we should use a fixed value for the visual radius, namely, should we fix $r_S = 
  %r_{\astrosun}(t_{\mathrm{mid},S})$. Radio frequency $\SI{37}{GHz}$ probes slightly higher altitudes compared to 
  %visible light, and we might thus expect a larger physical solar radius compared to $R_{\astrosun} = 6.957\times 10^8 
  %\mathrm{m}$. The standard value $R_{\astrosun}$ is based on visible light and optical depth of $\frac{2}{3}$. \skk{I 
  %have managed to produce an estimate $R_{\astrosun} = 7.10 \times 10^8 \mathrm{m}$ using an inversion model solver.}

  %We consider two disk methods to determine the solar disk position and size
  %from each map:
  %\begin{enumerate}
  %  \item $S$-curve and centre of mass: weighting the coordinates by the
  %  radio specimen intensity, $S$, center of mass.
  %  \item Convex hull: fitting a circle to those specimen coordinates, which
  %  we expect to belong to the solar limb, based on the geometry.
  %\end{enumerate}
  %We also consider three methods of signal level normalisation to identify
  %consistently between observations QSL and black sky:
  %\begin{enumerate}[a]
  %  \item  sort the intensity specimens and detect the point of zero curvature
  %  of the $S$-curve (specimen index vs. intensity).
  %  \fag{What is meant by constant fraction?}  
  %  \item iteratively calculate the statistical mean and standard deviation,
  %  excluding outliers, of the intensity of those points that are located
  %  within the solar disk and not too close to the limb.
  %  \item  detect two significant peaks from the intensity histogram,
  %  the lower intensity peak being the background and the higher the QSL.
  %\end{enumerate}
  %In this study, we present the optimal method combinations 1a, 2b and 2c.
%------------------------------------------------------------------------------
  \fag{Summarise the above and move the details to an appendix?}
  The initial normalised intensities $v_i^{(0)}$ can now be assigned using Equation~\ref{map_normalisation}.
  
  \subsection{Initial centering}\label{sect:initial_centering}
  
Most samples belong either to the background or the disk. Both of these regimes constitute a narrow range of intensity 
  values and are observed as high slopes on $w(u)$. The limb region, however, contains more diverse intensity values and 
  produces a middle plateau in $w(u)$. We need an algorithm to define the exact center of this plateau for every map, and
  %MJK Limb samples only are shown in the lower panel, right? Please refer to the different panels appropriately.
  thus fit a sequence cubic (of degree $\s{n}{sc}=3$) polynomials $P_k$ such that:
  \eqnl{scurve-approx}{
  P_k(u) = \sum \limits_{n=0}^{\s{n}{sc}} a_n^{(k)} u^j \approx w(u) \text{.}
  }
  The fitting is performed as a quadratic optimization problem where we minimize the value of a target function $T_k$ over the domain $[\s{j}{min}^{(k)}, \s{j}{max}^{(k)}]$:
  \eqnl{scurve-target}{
  T_k(\bm{a}_k) = \sum \limits_{j = \s{j}{min}^{(k)}}^{\s{j}{max}^{(k)}} \left( w \left( w^{-1}(j) \right) - P_k \left( w^{-1}(j) \right) \right)^2 \text{.}
  }


  For map $S$, we will calculate the weighted center of sample coordinates. For each sample $s_i \in S$ will be assigned an initial weight $b_i$:
  \eqnl{centering-initial-weight}{
  b_i^{(0)} := \begin{cases} 1 & \text{when}\; v_i^{(0)} \ge 0.85 \\ \frac{v_i^{(0)} - 0.15}{0.85 - 0.15} & \text{when}\; 0.15 < v_i^{(0)} < 0.85 \\ 0 & \text{when} v_i^{(0)} \le 0.15 \end{cases} \text{.}
  }
  Then center of mass is then:
  \eqnl{centering-center-of-mass}{
  \left( x^{(0)}, y^{(0)} \right) := \frac{\sum \limits_{i=1}^{N_S} b_i^{(0)} \left( x_i^{(0)}, y_i^{(0)} \right)}{\sum \limits_{i=1}^{N_S} b_i^{(0)}} \text{.}
  }
  This defines the initial center of the solar disk for the map, but it is further optimized below, starting from Sect.~\ref{sect:further_optimization}.

  \skk{Currenly, the code is not measuring the radius for each map. I implemented the functionality for 
  that, but probably we don't need it. If it turns out that the relative scale is inaccurate and varies between maps, we 
  can start using it. Maybe it would be clearer to omit the radius mode altogether. I just feel that it is relatively 
  easy to include the radius as a free parameter in case we so desire. If we think this as a methodology paper, the 
  radius measurement is a good bonus.}  
    \skk{I decided it is easier to convert the code into such form that it is easier to document, and the document it. 
    So now the S-curve -method and the calibration stuff described by J. Aatrokoski in MRO is used as an initiation step 
    for an iteration process. This iteration process selects limb samples a estimates they distance from the center. It 
    then fits a circle and neglects outliers. The centering is performed iteratively. I am almost done describing the 
    process thoroughly.}

    \skk{I though earlier about performing a comparison of the effectiviness of my convex hull method / limb model, the 
    S-curve method and the Shabasaki method. Actually these three methods are not completely overlapping in what they 
    perform, so they do not compete. And what I do is more iterative, and these two other methods only provide a 
    starting point for the iteration. Actually, I also wrote a simple method for producing a starting point, but the 
    S-curve method is more effective so I changed the code to use S-curve method first.}

    \skk{Anyway, the limb model -based iteration is what actually makes the centering.}
    
    \skk{There is another issue which I think is more serious. Metsähovi maps metadata are based on the standard value 
    for solar radius, $6.957 \times 10^8 \mathrm{m}$. For $\SI{8.1}{nm}$ wavelength, value $7.101 \times 10^8 
    \mathrm{m}$ is more realistic, based on \cite{Rozelot15,SKGVC19}. By analyzing the Metsähovi maps I have managed to produce 
    two different values, based on different approaches. One, based on single day maps, produces $7.10 \times 10^8 
    \mathrm{m}$, which is pretty close. By using cycle 24 and a different definition for the radius, I arrive at $7.18 
    \times 10^8 \mathrm{m}$. I am currently reprosessing the data based on the later value of the radius.}
    
  \subsection{Initial radius}\label{sect:initial_radius}

  It is possible to calculate the radius of the disk as well. We start by calculating area integrals of a function $f(x,y) = x^2+y^2 = r^2$ over a disk of radius $R$, $\mathcal{B}(\bm{0},R)$. This gives:
  \eqnl{initial_radius}{
  Q = \int \limits_{(x,y) \in \mathcal{B}(\bm{0},R)} \! r^2 \dd x \dd y = \intef{r}{0}{R}{2 \pi r^3} = \frac{2 \pi}{4} \intes{r}{0}{R}{r^4} = \frac{\pi R^4}{2} \text{.}
  }
  The area of such a disk is $A = \pi R^2$. Thus the average value of $f(x,y)$ is:
  \eqnl{initial_radius2}{
  \ave f(x,y) = \frac{Q}{A} = \frac{R^2}{2} \text{.}
  }
  Following this reasoning, the initial radius of the disk on the map $S$ is:
  \eqnl{initial_radius3}{
  r^{(0)} := \sqrt{2 \frac{\sum \limits_{i=1}^{N_S} b_i^{(0)} \left( \left( x_i - x^{(0)} \right)^2 + \left( y_i - y^{(0)} \right)^2 \right)}{\sum \limits_{i=1}^{N_S} b_i^{(0)}}} \text{.}
  }
  Per map calibration of the radius is useful if the scale of the relative right ascension and declination would be inaccurate.

  In here we have assumed that the radius is known in advance, i.e. $r^{(c)} = r_{\astrosun}(t_S)$ for all calibration rounds $c$. Time $t_S$ is the middle time of scanning $S$, namely:
  \eqnl{initial_radius_time}{
  t_S = \frac{\min{t_i :\; s_i \in S} + \max{ t_i :\; s_i \in S}}{2} \text{.}
  }

  \subsection{Physical radius of the Sun}\label{sect:physical_radius}
  
  In this paper, we have assumed that the scale of the relative right ascension and declination are correct and thus the 
  radius of the disk is based on geometry. Let $R_{\astrosun}$ be the physical radius of the Sun and $d(t)$ be the distance 
  between MRO on Earth and the physical center (core) of the Sun at time $t$. Then:
  \eqnl{visual_angle}{
  r(t) = \arcsin \left( R_{\astrosun} / d(t) \right) \text{.}
  }
  The apparent radius of the Sun depends on wavelength and method of observation as well as the exact definition. For radio wavelengths, a quadratic fit 
  of the apparent radius $\ave r$ is constructed in \cite{Rozelot15}. Evaluating this for $\SI{37}{GHz}$ ($\lambda = 
  \SI{8.1}{mm}$ and the avarage distance of $\ave d = \SI{1}{AU}$, we obtain $R_{\astrosun} = 7.1006 \times 10^8 
  \mathrm{m}$.

  We have analyzed the solar radius using two different definitions which apply to MRO solar maps. Both definitions are 
  recursive and, by experience, shown to be convergent. They are described throughly in 
  Sections~\ref{sect:radius_method1} and~\ref{sect:radius_method2}. As for this paper we use the experimental value 
  $R_{\astrosun} = 7.176 \times 10^8 \mathrm{m}$ because it provides $0.5$ QSL intensity at the disk boundary.

  \subsection{Iterative calibration} \label{sect:further_optimization}

  Having obtained the initial ($c=0$) center of the disk as $(x^{(c)}, y^{(c)})$, and optionally, its radius $r^{(c)}$, we 
  proceed iteratively for $c:=c+1$. We accept the background intensity $\s{u}{background}$ from the initial calibration while perform 
  more analysis in order to determine the inner disk signal levels properly. We measure the QSL and its standard 
  deviation, while outliers within the disk are neglected. Between each QSL determination loop, we refine the centering 
  of the disk.
  
  \subsection{Inner disk outliers} \label{sect:disk_outliers}

  We aim to calculate the average intensity within the disk. However, we do not use the whole inner disk for measuring 
  QSL, since it typically contains bright and dim features such as active regions. These features will be neglected as 
  outliers in a series of iterative rounds.

  The beam pointing may be slightly 
  irregular due to oscillations in pointing. See Fig.~\ref{typicalmap}{\bf(b)} for a typical antenna path. In 
  practice, the sweeps are moderately regular except for antenna wiggling, but our code does not expect uniform sample 
  density. We create a rectangular grid ($\Lambda$) of lattice points $\lambda_h \in \Lambda$. The lattice points are indexed via a set $I_{\Lambda}$:
  
  \eqnl{calib_inner_disk_lattice}{
  \Lambda = \left\{ \lambda_h :\; h \in I_{\Lambda} \right\} \text{.}
  }
  Each lattice point contains relative sky coordinates $\left( x_h, y_h \right)$ as well as an intensity value $u_h$:
  \eqnl{calib_inner_disk_point}{
  \lambda_h = \left( x_h, y_h, u_h \right) \text{.}
  }
  We can construct a lattice of desired integer resolution $\s{n}{grid} \in \mathds{N}$ by defining the index set as:
  \eqnl{calib_inner_disk_index}{
  I_{\Lambda} = \left\{ 0, 1, ..., \s{n}{grid}-1 \right\} \text{.}
  }
  We set up a rectangular frame to bound all the samples in $S$ as:
  \eqnl{calib_inner_disk_frame}{
  \s{x}{min} := \min{x_i:\, s_i \in S}, \; \s{x}{max} := \max{x_i:\, s_i \in S}, \; \s{y}{min} := \min{y_i:\, s_i \in S} \text{, and} \, \s{y}{max} := \max{y_i:\, s_i \in S} \text{.}
  }
  We define the index numbers as:
  \eqnl{calib_inner_disk_elem}{
  h = h_x \s{n}{grid} + h_y \; \text{where} \; 0 \le h_x,h_y < \s{n}{grid}, \; h_x,h_y \in \mathds{N} \text{.}
  }
  The coordinates are then obtained as:
  \eqnl{calib_inner_disk_lattice_x}{
  x_h := \s{x}{min} + \left( \s{x}{max} - \s{x}{min} \right) \frac{h_x}{\s{n}{grid}} \; \text{and}
  }
  \eqnl{calib_inner_disk_lattice_y}{
  y_h := \s{y}{min} + \left( \s{y}{max} - \s{y}{min} \right) \frac{h_y}{\s{n}{grid}} \text{.}
  }
  The intensity associated with a lattice point $\lambda_h$ is that of the nearest sample $s_i \in S$, which is obtained via mapping $i_{\Lambda}:\; I_{\Lambda} \mapsto I_S$:
  \eqnl{calib_inner_disk_lattice_u}{
  u_h := u_i, \; i = i_{\Lambda}(h) \text{.}
  }
  The mapping $i_{\Lambda}(h)$ transforms the lattice point of index $h$ into the map sample of index $i$, so that the nearest sample is chosen. The distance between $\lambda_h$ and $s_i$ is measured as $d_h$ using uncalibrated coordinates:
  \eqnl{calib_inner_disk_nearest1}{
  d_h^2 = \min{\left( x_i - x_h \right)^2 + \left( y_i - y_h \right)^2:\; s_i \in S} \; \text{and}
  }
  \eqnl{calib_inner_disk_nearest2}{
  \left( x_{i_{\Lambda}(h)} - x_h \right)^2 + \left( y_{i_{\Lambda}(h)} - y_h \right)^2 = d_h^2 \text{.}
  }
   When several map samples satisfy Equation~\ref{calib_inner_disk_nearest2}, the mapping $i_{\Lambda}(h)$ is chosen 
  arbitrarily. It is possible to use e.g. linear interpolation based on Voronoi tessellation here. However, currently it 
  is not implemented. \skk{I wanted to implement Voronoi tessellation but the code has already grown to have too many 
  features that it was not feasible. Currently I am working with the inversion model solver, which has no need for any 
  interpolation anyway. So writing the tessellation ready is still possible but a side step to my opinion, and that is 
  why I gave up.}
 
  For each calibration round $c$, we define the inner disk $I_c \subset \Lambda$ as the region that is within $0.9 r^{(c)}$ distance from origin, using centered coordinates:
  \eqnl{calib_inner_disk1}{
  I_c := \left\{ \lambda_h :\; \sqrt{\left( x_h - x^{(c)} \right)^2 + \left( y_h - y^{(c)} \right)^2} \le 0.9 r^{(c)} \right\} \text{.}
  }  
  For first outlier neglection round, we have $q=0$ and set $I_{c}^{(0)} := I_c$. We calculate the average intensity $\s{u}{QSL}^{(c,q)}$ and standard deviation $\s{\sigma}{QSL}^{(c,q)}$ as follows:
  \eqnl{calib_inner_disk2}{
  \s{u}{QSL}^{(c,q)} := \frac{1}{|I_{c}^{(q)}|} \sum \limits_{\lambda_h \in I_{c}^{(q)}} u_h \; \text{and}
  }
  \eqnl{calib_inner_disk3}{
  \s{\sigma}{QSL}^{(c,q)} := \sqrt{\frac{1}{|I_{c}^{(q)}|} \sum \limits_{\lambda_h \in I_{c}^{(q)}} \left( u_h - \s{u}{QSL}^{(c,q)} \right)^2} \text{.}
  }
  The subsequent outlier neglection rounds omit the lattice points whose intensities are not within two standard deviations from the average, when previous outliers are neglected:
  \eqnl{calib_inner_disk4}{
  I_c^{(q+1)} := \left\{ \lambda_h \in I_c^{(q)} :\; \left|u_h^{(c)} - \s{u}{QSL}^{(c,q)} \right| \le 2 \s{\sigma}{QSL}^{(c,q)} \right\} \text{.}
  }
  After a few rounds, $q = \s{q}{max}$, the set of non-outliers converges and we have obtained a new reference 
  intensity. We can now define the QSL and its standard deviation for the next calibration round $c \mapsto c+1$ as:
  \eqnl{calib_inner_disk5}{
  I_{c+1}^{(\mathrm{QSL})} := I_{c}^{(\s{q}{max}+1)},\; \s{u}{QSL}^{(c+1)} := \s{u}{QSL}^{(c,\s{q}{max})} \text{, and} \; \s{\sigma}{QSL}^{(c+1)} := \s{\sigma}{QSL}^{(c,\s{q}{max})} \text{.}
  }
  For the next calibration round, the sample intensities are renormalized:
  \eqnl{calib_inner_disk6}{
  v_i^{(c+1)} := \frac{u_i - \s{u}{background}}{\s{u}{QSL}^{(c+1)} - \s{u}{background}} \text{.}
  }
  The first time we run the above substitions (Sect.~\ref{sect:disk_outliers}) is for $c=0$.

  \subsection{Bright and dim features} \label{sect:bright_dim_features}

  From now on, the first round is for $c=1$. We separate the inner disk of the previous centering round, $I_{c-1}$, into three subsets, 
  $I_c^{(\mathrm{dim})}$, $I_c^{(\mathrm{QSL})} = I_{c-1}^{(\s{q}{max}+1)}$, and $I_c^{(\mathrm{bright})}$ based on 
  normalized signal levels:
  \eqnl{calib_features_dim}{
  I_c^{(\mathrm{dim})} := \left\{ \lambda_h \in I_{c-1} :\; u_h - \s{u}{QSL}^{(c)} < -2 \s{\sigma}{QSL}^{(c)} \right\} \; \text{and}
  } 
  \eqnl{calib_features_bright}{
  I_c^{(\mathrm{bright})} := \left\{ \lambda_h \in I_{c-1} :\; u_h - \s{u}{QSL}^{(c)} > 02 \s{\sigma}{QSL}^{(c)} \right\} \text{.}
  } 
  We will partition the lattice points in $I_c^{(\mathrm{dim})}$ and $I_c^{(\mathrm{bright})}$ into a set of features $\mathcal{F}_c$ such that:
  \eqnl{calib_features2}{
  \bigcup \limits_{F \in \mathcal{F}_c} F = I_c^{(\mathrm{dim})} \cup I_c^{(\mathrm{bright})} \text{.}
  }
  Any two features $F, F^{\prime} \in \mathcal{F}_c$, $F \ne F^{\prime}$ are separate such that $F \cap F^{\prime} = 
  \emptyset$. Any two neighbouring lattice points $\lambda_h, \lambda_{h^{\prime}} \in I_c$ satisfy the clustering 
  requirement. If either $\lambda_h,\lambda_{h^{\prime}} \in I_c^{(\mathrm{dim})}$ or $\lambda_h,\lambda_{h^{\prime}} 
  \in I_c^{(\mathrm{bright})}$, then there is a feature $F \in \mathcal{F}_c$ such that $\lambda_h,\lambda_{h^{\prime}} 
  \in F$. Thus any connected bright or dim pattern on the solar disk, significantly outside the range of the QSL 
  intensitities, will constitute a feature $F \in \mathcal{F}_c$. The features are typically bright and dim regions on 
  chromosphere, but they can also arise from instrumental effects just as changing weather conditions during observation 
  of $S$.
  
  The area of a feature $F$, $A(F)$, is the number of lattice points in $F$ times the lattice square area:
  \eqnl{calib_features3}{
  A(F) := |F| \frac{\left( \s{x}{max} - \s{x}{min} \right) \left( \s{y}{max} - \s{x}{min} \right)}{\s{n}{grid}^2} \text{.}
  }
  We define the radius $r(F)$ of a feature $F$ as the radius of circle which has area $2 A(F)$:
  \eqnl{calib_features4}{
  r(F) := \sqrt{\frac{2 A(F)}{\pi}} \text{.}
  }
  The location $z(F)$ of a feature $F \in \mathcal{F}_c$ is calculated as a center of mass using calibrated coordinates and QSL relative intensity as weight:
  \eqnl{calib_features5}{
  z(F) := \left( x(F), y(F) \right) = \frac{\sum \limits_{\lambda_h \in F} \left( x_h, y_h \right) \left| u_h - \s{u}{QSL}^{(c)} \right|}{\sum \limits_{\lambda_h \in F} \left| u_h - \s{u}{QSL}^{(c)} \right|} - \left( x^{(c-1)}, y^{(c-1)} \right) \text{.}
  }

  \subsection{Limb outliers} \label{sect:outliers_limb}

  In the next step of this algorithm, we will neglect those antenna samples which are too close to any known feature. We form a set $L^{(c)}_1 \subset S$ based on Equation~\ref{calib_features5}.
  \eqnl{calib_features6}{
  L^{(c)}_1 := S \setminus \bigcup \limits_{F \in \mathcal{F}_c} \left\{ s_i \in S: \; \sqrt{\left( x^{(c-1)}_i - x(F) \right)^2 + \left( y^{(c-1)}_i - y(F) \right)^2} \le r(F) \right\} \text{.}
  }
  We will calculate a relative radial distance for each sample $s_i \in S$ based on previous round $c-1$:
  \eqnl{calib_radial_distance}{
  r_i^{(c)} := \frac{\sqrt{\left( x_i - x^{(c-1)} \right)^2 + \left( y_i - y^{(c-1)} \right)^2}}{r^{(c-1)}} \text{.}
  }
  For detecting limb outliers, we collect a subset $L^{(c)}_2 \subset S$ of the map $S$ which restricts radial distances into the boundary region:
  \eqnl{calib_subset1}{
  L^{(c)}_2 := \left\{ s_i \in S:\; 0.96 \le r_i^{(c)} \le 1.04 \right\} \text{.}
  }
  These points reside at the limb when it comes to the current centering round $c$. Further requirement for the limb is that the intensities must also be consistent with being on the limb, defining another subset.
  \eqnl{calib_subset2}{
  L^{(c)}_3 := \left\{ s_i \in S:\; 0.05 \le v_i^{(c)} \le 0.95 \right\} \text{.}
  }
  The final boundary set $L^{(c)}$ is taken as:
  \eqnl{calib_subset3}{
  L^{(c)} := L^{(c)}_1 \cap L^{(c)}_2 \cap L^{(c)}_3 \text{.}
  }
  We thus want to avoid any known chromospheric features when they are close to the limb, since they would produce 
  exceptional values there and interfere with proper centering. Having obtained $L^{(c)}$, we calculate a radial 
  estimate: $r_i^{\prime(c)}$, for each $s_i \in L^{(c)}$. This is based on a known limb profile $l_{p,S}(r)$. For details on how the 
  limb model is obtained, please refer to Sect.~\ref{sect:radius_method1}. Initially, we had no forehand details of 
  the limb and the model had to be constructed using more rudimentary methods. Another option for bootstrapping is to assume a simple linear function for the first limb model round $p=0$:
  \eqnl{calib_limbmodel1}{
  l_{0,S}(r) = \frac{1.04 - r}{1.04 - 0.96} \text{.}
  }
  After maps of a given solar cycle have been processed, we can construct a more sophisticated limb model for the next grand iteration round $p := p+1$. First we need 
  to optimize the target in Equation~\ref{physical_radius_target} and obtain parameters for functions in 
  Equation~\ref{physical_radius_polynomials}. Denote $a_S = a_{\astrosun}(t_S)$ for the altitude where the center of the Sun is as seen from 
  MRO during observation of map $S$. The limb model for $S$ at round $p \ge 1$ is 
  then:
  \eqnl{calib_limbmodel2}{
  l_{p,S}(r) = \frac{B(\bm{x}_m^{(p)}, \rho(r), a_S)}{B(\bm{x}_m^{(p)}, \rho(1/3), a_S)} \text{.}
  }
  The parameter set $\bm{x}_m^{(p)}$ is optimized for round $p$ and with sufficiently large $m$. Fig.~\ref{limb_brightening} illustrates the optimized limb profiles of cycle 24 for the applicable range of altitudes.
  The radial estimate is obtained from the inverse of $l_{p,S}(r)$ as:
  \eqnl{calib_limbmodel3}{
  l_{p,S}(r_i^{\prime(c)}) = v_i^{(k)} \implies r_i^{\prime(c)} := l_{p,S}^{-1}(v_i^{(c)}) \text{.}
  }
  The radial error for each sample $s_i$ is then calculated as difference between the real and estimated radius:
  \eqnl{calib_deviation1}{
  \delta r_i^{(c)} := r_i^{(c)} - r_i^{\prime(c)} \text{.}
  }
   We want to neglect outliers for which the radial error is too high. These are associated with activity on the limb or 
  a with an instrumetal error. The outlier filtering is done iteratively, starting with $g=4$ and setting $L^{(c)}_4 := 
  L^{(c)}$.
  For a given set of limb samples, $L^{(c)}_g$, we can calculate the standard deviation of radial estimates as:
  \eqnl{calib_deviation2}{
  \Delta \left( L^{(c)}_g \right) = \sqrt{\frac{\sum \limits_{s_i \in L^{(c)}_g} \left( \delta r_i^{(c)} \right)^2}{\left|L^{(c)}_g \right|}} \text{.}
  }
  The subsequent boundary sets $g \mapsto g+1$ are constructed from $L^{(c)}$ as follows:
  \eqnl{calib_deviation3}{
  L^{(c)}_{g+1} = \left\{ s_i \in L^{(c)} : \; \left|\delta r_i^{(c)} \right| \le 2 \Delta \left( L^{(c)}_{g} \right) \right\} \text{.}
  }
  After a couple of steps we have neglected any outliers with good reliability. We can use the limb set $L^{(c)}_{\s{g}{out}}$ with $\s{g}{out} := 10$for this.

  \subsection{Subsequent centering} \label{sect:subsequent_centering}

  We will fit a circle into the set $L^{(c)}_{\s{g}{out}}$. The quality of fitting is evaluated as $T_c$:
  \eqnl{subsequent_centering1}{
  T_c(\bm{z}) = \sum \limits_{s_i \in L^{(c)}_{\s{g}{out}}} \left( \sqrt{\left( x_i - x \right)^2 + \left( y_i - y \right)^2} - r_i^{(c)} r \right)^2 \text{.}
  }
  Here the vector $\bm{z} = \left( x, y, r \right)^T$.
  The radius $r$ is optionally a free parameter, otherwise we fix $r := r^{(c)} = r^{(0)}$ (see 
  Sect.~\ref{sect:initial_radius}). We search of optimal values $\bm{z}_{\zeta}^{(c)}$ which minimize $T_c$, starting with $\zeta=0$:
  \eqnl{subsequent_centering2}{
  \bm{z}_0^{(c)} := \left( x^{(c-1)}, y^{(c-1)}, r^{(c-1)} \right)^T \text{.}
  }
  We assume that $T_c(\bm{z})$ is locally quadratic with $H_c(\bm{z})$ begin the Hessian of $T_c(\bm{z})$:
  \eqnl{subsequent_centering3}{
  T_c(\bm{z}+\delta \bm{z}) \approx T_c(\bm{z}) + \delta \bm{z}^T \nabla T_c(\bm{z}) + \frac{1}{2} \delta \bm{z}^T H_c(\bm{z}) \delta \bm{z} \text{.}
  }
  The quadratic approximation has minimum at: $\delta \bm{z} = -H_c^{-1}(\bm{z}) \nabla T_c(\bm{z})$. By iterating as:
  \eqnl{subsequent_centering4}{
  \bm{z}_{\zeta+1} := \bm{z}_{\zeta} - H_c^{-1}(\bm{z}_{\zeta}) \nabla T_c(\bm{z}_{\zeta}) \text{,}
  }
  we arrive at a true minimum of $T_c$ in few steps. The convergence is detected when the value of $T_c$ no longer 
  decreases in subsequent iterations due to numerical limits and small shift $\delta \bm{z}_{\zeta}$. This optimum value defines the new center and radius for the map:
  \eqnl{subsequent_centering5}{
  \left( x^{(c)}, y^{(c)}, r^{(c)} \right)^T := \lim \limits_{\zeta \to \infty} \bm{z}_{\zeta} \text{.}
  }
  We will now loop back to Sect.~\ref{sect:disk_outliers} unless we have reached $c = \s{c}{max} := 5$. \skk{Hey, natural language is also a programming language.}
  In subsequent sections, we will use the fully calibrated values $x_i^{(\s{c}{max})}$, $y_i^{(\s{c}{max})}$, and $r_i^{(\s{c}{max})}$ for each sample $s_i \in S$.

\skk{Moved the convex hull stuff into a separate file, probably not to be included in the paper.}

%------------------------------------------------------------------------------
\subsection{Limb correction model}\label{sect:limb}

%FAG rephrase
%We intend to estimate the brightness ($v$) based on time ($t$), heliographic latitude ($\theta$), angular distance from the 
%%MJK comma '...disk, as seen...'
%center of solar disk as seen at the time of observation ($r$), and the altitude above the horizon ($\varphi$). The model 
%will contain polynomials of high degree, so that numerical stability is a concern. We need to carefully select the 
%domains for each parameter. Radians are a natural choice of units for $\theta, \varphi \in \left( 0, \frac{\pi}{2} 
We seek to determine the brightness ($v$) at time ($t$), heliographic latitude
($\theta$) and angular distance from the centre of solar disk, based on an
%FAG we introduce r here, but do not appear to use it and can confuse with radius
%FAG: does it refer to the observation time or the observation as a specimen?
observation at time ($\tau$) and altitude above the horizon ($\varphi$).
We model with polynomials of high degree, so care with numerical stability is 
required, matching separately domains for each parameter.
Radians are a natural choice of units for $\theta, \varphi \in \left( 0, \pi/2 
%FAG reformat
%\right)$. For time, $t = \frac{a - 2005}{10}$, where $a$ is a real number $a = 1970 + 
%\frac{\mathrm{unixtime}}{60\cdot60\cdot24\cdot365.25}$. Radius $r$ is represented as relative to the visual solar radius, which can 
%either be calculated from our astronomical model or fitted to the data as a circle.
\right)$. For time, $t = (a - 2005)/10$, where $a$ is a real number $a = 1970 +
\mathrm{unixtime}/(60\cdot60\cdot24\cdot365.25)$. Radius $r$ is represented as
%FAG: sami is this correct reference to methods
relative to the visual solar radius, which can be calculated either from our
astronomical model (method 1) or fitted to the data as a circle (method 2).

%FAG. is this a repeat of 2.2
The solar map is a collection of intensity values $\left\{ v_i \right\}_i$ 
sampled by the antenna.
These are linearly scaled so that $1$ represents the QSL and $0$ represents
the black sky.
Each intensity value $v_i$ is accompanied with right ascension $\delta \mathrm{RA}_i$ and declination $\delta 
\mathrm{dec}_i$relative to the center of the solar disk, $\left( \mathrm{RA}_{\mathrm{sun}}(t_i), 
\mathrm{dec}_{\mathrm{sun}}(t_i) \right)$, at the time of observation, $t_i$.


Moreover, $\varphi_i$ will be the altitude of the solar center at the time of observation, relative 
to observers horizon. It is measured in radians, and in practice samples will have the range:
\eqnl{altitude_range}{
\varphi_i \in \left[ \frac{5}{180} \pi, \frac{53}{180} \pi \right] \text{.}
}
%FAG added reference to Fig 3 and para break. Sami is this correct and an
%FAG appropriate place to mention the Fig?
In Fig.~\ref{limb_brightening}(a), we show the effect of limb brightening for
observations within the range $\varphi_i\in[7\deg,52\deg]$, and in
Fig.~\ref{limb_brightening}(b) the corresponding correction profiles, which 
are applied near the limb to compensate.

  \subsection{Determining radius by limb intensity} \label{sect:radius_method1}

  The first method is performed using the all MRO solar maps of the cycle $24$, combining c.a. $75800$ maps. For each 
  map, we perform the calibration procedure described in Sect.~\ref{sect:source} and concatenate the samples into a 
  big list of c.a. $2 \times 10^8$ samples. The next step in the analysis involves five data fields per sample:
  \begin{itemize}
  \item Time (on solar cycle 24): $t_j$.
  \item Heliographic latitude: $l_j$.
  \item Distance from the center of disk, relative to the apparent radius of the disk: $r_j$.
  \item Altitude of observation, angle with respect to horizon at MRO: $a_j$.
  \item Normalised intensity: $v_j$.
  \end{itemize}

  Here the index $j$ is mapped to some sample $s_i$ on some map $S$, and $j$ runs over all the maps of cycle $24$. The 
  distance $r_j$ is zero at the center and unity at the boundary of the disk.
    The polynomial $A$ should compensate for the butterfly diagram of cycle $24$, which is intensity vs. time and heliographic latitude. Meanwhile, the polynomial $B$ should compensate any limb effects.
  We emphasize the boundary at $r=1$ by transforming to $\rho$ as:
  \eqnl{physical_radius_trans}{
  \rho_j := \arctan \left( \kappa \left( r_j - 1 \right)\right) \; \text{with} \; \kappa = 8.8 \text{.}
  }
  We then perform an optimization to 
  minimize a target function:
  \eqnl{physical_radius_target}{
  U(\bm{x}) = \sum \limits_{j=1}^{N} \left( A(\bm{x},t_j,l_j) B(\bm{x},\rho_j,a_j) - v_j \right)^2 \text{.}
  }
  Here the functions $A$ and $B$ are two-dimensional polynomials of $(t,l)$ and $(\rho,a)$, respectively, with coefficients obtained from individual elements of the vector $\bm{x}$. We write the polynomials as:
  \eqnl{physical_radius_polynomials}{
  A(\bm{x},t,l) = \sum \limits_{g=0}^{4} \sum \limits_{h=0}^{4-g} c_{g,h} t^g l^h \; \text{and} \;
  B(\bm{x},\rho,a) = \sum \limits_{g=0}^{6} \sum \limits_{h=0}^{6-g} d_{g,h} \rho^g a^h \text{.}
  }
  The vector $\bm{x}$ is constructed from coefficients $c_{g,h}$ and $d_{g,h}$. With current selection of degrees $4$ 
  and $6$ for polynomials $A$ and $B$, respectively, we will have $6*5/2 + 8*7/2 = 43$ elements in $\bm{x}$. The element 
  $\bm{x}^{(0)}$ refers to $c_{0,0}$, and $\bm{x}^{(15)}$ refers to $d_{0,0}$.

  The optimization is performed iteratively. We start with an initial vector $\bm{x}_0$, where each element 
  $\bm{x}_0^{(g)}$ will be a small random value, except for $g=0,15$where we start with $\bm{x}^{(g)} = 1$, thus 
  setting $c_{0,0} = d_{0,0} = 1$ and giving a flat solar cycle and flat disk with some noise. We proceed with iterative 
  steps of quadratic optimization. At each step $m$ we calculate the gradient $\bm{g}_m := \nabla U(\bm{x}_m)$ and the Hessian of $U(\bm{x_m}$, which should be $H_m$. Basically we search for the point of zero gradient iteratively, starting from $m=0$:
  \eqnl{physical_radius_step}{
  \bm{x}_{m+1} := \bm{x}_m - H_m^{-1} \bm{g}_m \text{.}
  }

  However, this naive approach will easily run into trouble when we are far from the actual minimum of $U(\bm{x})$. For 
  this reason, we have a developed a more rebust scheme which first diagonalizes $H_m$. The algorithm tries to choose 
  how much to advance along each eigenvector of $H_m$. The algorithm tries to avoid the eigenvectors accociated with 
  negative eigenvalues, but will eventually descend away from possible saddle points.
  
  We force the disk to be flat at the center, thus $\frac{\partial B}{\partial r}\big|_{r=0} = 0$. This limits the 
  subspace allowed for $\bm{x}$ and reduces the amount of degrees of freedom in the setting to $37$. The optimization stops successfully (converges) at step $m$ when we observe that:
  \begin{itemize}
  \item $H_m$ is positively definite in the allowed subspace.
  \item The next step $\bm{x}_{m+1} - \bm{x}_{m}$is comparable to numerical precision.
  \item $U(\bm{x}_{m+1})$ is equal or slightly greater than $U(\bm{x}_m)$ due to limits in the numerical precision.
  \end{itemize}

  Having optimized $U(\bm{x}_{m})$ at sufficient amount of steps ($m$), we define the limb profile $L(r)$ for a given altitude $a = 30^{\circ}$ as:
  \eqnl{physical_radius_limb}{
  L(r) := \frac{B(\bm{x}_m, \rho(r), a)}{B(\bm{x}_m, \rho(1/3), 30^{\circ})} \text{.}
  }
  We thus state that the reference Sun is observed on altitude $30^{\circ}$ above horizon. The function $L(r)$ is a $6$:th degree polynomial of $\rho(r)$. We search for the value $\s{r}{limb}$ where:
  \eqnl{physical_radius_limb2}{
  L(\s{r}{limb}) = 0.5 \text{.}
  }
  We start the above process using a reasonable value for the physical radius of the Sun, namely, $R_{\astrosun}^{(0)}$. 
  Starting from $q=0$, the process gives a value of $\s{r}{limb}^{(q)} \approx 1$. When there is a slight deviation from 
  unity, we correct that into the physical Sun radius by setting:
  \eqnl{physical_radius_iteration}{
  R_{\astrosun}^{(q+1)} := Q_{\astrosun}^{(q)} * \s{r}{limb}^{(q)}
  }
  After a few steps, the radius $R_{\astrosun}^{(q+1)}$no longer evolves. So far we have obtained a convergent value of $R_{\astrosun}^{(\infty)} \approx 7.176 \times 10^8 \mathrm{m}$.

  \subsection{Determining radius by inversion model} \label{sect:radius_method2}

  We start with a predefined $R_{\astrosun}$ and sweep the reasonable interval $[6.90, 7.25] \times 10^8 \mathrm{m}$. 
  Currently the model works on a few $n \approx 14$ maps at once. This does not analyze a full solar cycle but rather a 
  single day of observations. The model involves a centering scheme similar to that in described fully in 
  Sect.~\ref{sect:s_curve}, \ref{sect:initial_centering}, \ref{sect:further_optimization}, and~\ref{sect:outliers_limb}. However, this 
  scheme involves solving the inversion problem several times and constructing the limb model for each map individually 
  each time the inversion problem is solved. This approach tackles not only the different altitude of observation 
  depending on time of day, but also varying weather and atmospheric conditions which affect the telescope beam. The 
  model omits outlier samples using a similar recursive scheme as described completely in 
  Sect.~\ref{sect:outliers_limb} and~\ref{sect:disk_outliers}.

  Each sample constitutes of four values: $s_j = (t_j, x_j, y_j, v_j)$, where $t_j$ is time, $v_j$ is calibrated intensity, 
  and $(x_j,y_j)$ describe the position of the sample on the calibrated disk as right ascension and declination 
  relative to the center of the Sun. We parametrize the telescope beam $B(z^2)$with a polynomial times a gaussian function of known width $\sigma$:
  \eqnl{inversion_beam}{
  B(z^2) = e^{-\frac{z^2}{2 \sigma^2}} \sum \limits_{g=0}^{4} b_g z^{2g} \text{.}
  }
  Here $z$ refers to the relative angle between a source element and the observed sample. We only need even powers of $z$ in the polynomial factor since the beam is radially symmetric. We produce an estimate $e_j$for each sample $s_j$ through integrating over the telescope beam:
  \eqnl{inversion_beam2}{
  e_j = \intef{x^{\prime}}{-\infty}{+\infty}{ \intef{y^{\prime}}{-\infty}{+\infty}{ f(x^{\prime}, y^{\prime}) B \left( \left( x - x^{\prime} \right)^2 + \left( y - y^{\prime} \right)^2 \right)}}
  }

  The integral in Equation~\ref{inversion_beam2} is evaluated numerically using Gaussian quadratures. There are 
  $7$cocentric rings of quadrature points around the sample $(x_j,y_j)$. The radii of the rings come from a quadrature 
  rule with gaussian weight function. Each ring contains $6$ quadrature points, and the placement of the points along the ring comes from a linear 
  quadrature rule. Various ad hoc solutions are implemented in order to handle singularities and discontinuities at the 
  disk boundary as well as to maintain sufficient numerical stability.

  Once the quadratures are implemented, we arrive into a linear summation formula for each sample $s_j$. The coefficients $\xi_{j,i}$ are calculated as a products of the corresponding ring and point quadrature coefficients.
  \eqnl{inversion_beam3}{
  \epsilon_j = \sum \limits_{i=1}^{42} \xi_{j,i} f(x^{\prime}_{j,i}, y^{\prime}_{j,i} \approx e_j \text{.}
  }

   We project each of the sky coordinates $((x^{\prime}_{j,i}, y^{\prime}_{j,i})$ at time $t_j$ on the spherical solar 
   surface with radius $R_{\astrosun}$. This gives us the heliographic latitude $l^{\prime}_{j,i}$ of the point where the line of sight is incident with the solar surface. We denote by $\alpha_{j,i}$ the angle of incidence.
   
  We have a polynomial $A$ for describing the current phase of the solar 
   cycle.
   


